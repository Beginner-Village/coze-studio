/*
 * Copyright 2025 coze-dev Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cardselector

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/coze-dev/coze-studio/backend/domain/workflow/entity"
	"github.com/coze-dev/coze-studio/backend/domain/workflow/entity/vo"
	"github.com/coze-dev/coze-studio/backend/domain/workflow/internal/canvas/convert"
	"github.com/coze-dev/coze-studio/backend/domain/workflow/internal/nodes"
	"github.com/coze-dev/coze-studio/backend/domain/workflow/internal/schema"
	"github.com/coze-dev/coze-studio/backend/pkg/sonic"
)

const (
	InputKeySearchKeyword    = "search_keyword"
	InputKeyCardFilters      = "card_filters"
	InputKeySelectedCardID   = "selected_card_id"
	InputKeySelectedCard     = "selected_card"
	InputKeyInputParameters  = "input_parameters"

	OutputKeySelectedCard = "selected_card"
	OutputKeyCardID       = "card_id"
	OutputKeyCardName     = "card_name"
	OutputKeyCardDesc     = "card_description"
	OutputKeyCards        = "cards"
	OutputKeyCount        = "count"
	// Êñ∞Â¢ûÁöÑÊ®°ÊùøËæìÂá∫ÈîÆ
	OutputKeyTemplateResponse = "template_response"
)

// ËæÖÂä©ÂáΩÊï∞ÔºöËé∑ÂèñmapÁöÑÊâÄÊúâÈîÆ
func getMapKeys(m map[string]any) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// FalconCard represents a card from the Falcon platform
type FalconCard struct {
	CardID          string `json:"cardId"`
	CardName        string `json:"cardName"`
	Code            string `json:"code"`
	CardClassID     string `json:"cardClassId,omitempty"`
	CardPicURL      string `json:"cardPicUrl,omitempty"`
	CardShelfStatus string `json:"cardShelfStatus,omitempty"`
	CardShelfTime   string `json:"cardShelfTime,omitempty"`
	CreateUserID    string `json:"createUserId,omitempty"`
	CreateUserName  string `json:"createUserName,omitempty"`
	PicURL          string `json:"picUrl,omitempty"`
	SassAppID       string `json:"sassAppId,omitempty"`
	SassWorkspaceID string `json:"sassWorkspaceId,omitempty"`
	BizChannel      string `json:"bizChannel,omitempty"`
}

// FalconAPIRequest represents the API request body
type FalconAPIRequest struct {
	Body FalconRequestBody `json:"body"`
}

type FalconRequestBody struct {
	AgentID             string          `json:"agentId"`
	ApplyScene          string          `json:"applyScene"`
	CardClassID         string          `json:"cardClassId"`
	CardCode            string          `json:"cardCode"`
	CardID              string          `json:"cardId"`
	CardName            string          `json:"cardName"`
	CardPicURL          string          `json:"cardPicUrl"`
	Channel             string          `json:"channel"`
	Code                string          `json:"code"`
	CreateTime          string          `json:"createTime"`
	CreatedBy           bool            `json:"createdBy"`
	GreyConfigInfo      string          `json:"greyConfigInfo"`
	GreyNum             string          `json:"greyNum"`
	ID                  string          `json:"id"`
	IsAdd               string          `json:"isAdd"`
	JSFileURL           string          `json:"jsFileUrl"`
	MainURL             string          `json:"mainUrl"`
	Memo                string          `json:"memo"`
	ModuleName          string          `json:"moduleName"`
	PageNo              string          `json:"pageNo"`
	PageSize            string          `json:"pageSize"`
	PicURL              string          `json:"picUrl"`
	Platform            string          `json:"platform"`
	PlatformStatus      string          `json:"platformStatus"`
	PlatformValue       string          `json:"platformValue"`
	PreviewSchema       string          `json:"previewSchema"`
	PublishMode         string          `json:"publishMode"`
	PublishStatus       string          `json:"publishStatus"`
	PublishType         string          `json:"publishType"`
	RealGreyEndtime     string          `json:"realGreyEndtime"`
	ResourceType        string          `json:"resourceType"`
	SassAppID           string          `json:"sassAppId"`
	SassWorkspaceID     string          `json:"sassWorkspaceId"`
	SchemaValue         string          `json:"schemaValue"`
	SearchValue         string          `json:"searchValue"`
	ServiceModuleID     string          `json:"serviceModuleId"`
	ServiceName         string          `json:"serviceName"`
	SkeletonScreen      string          `json:"skeletonScreen"`
	SoLib               string          `json:"soLib"`
	StaticMemo          string          `json:"staticMemo"`
	StaticType          string          `json:"staticType"`
	StaticVersion       string          `json:"staticVersion"`
	TaskID              string          `json:"taskId"`
	TaskStatus          string          `json:"taskStatus"`
	TemplateID          string          `json:"templateId"`
	TemplateName        string          `json:"templateName"`
	TemplateSchemaValue string          `json:"templateSchemaValue"`
	UnzipPath           string          `json:"unzipPath"`
	UserID              string          `json:"userId"`
	VariableValueList   []VariableValue `json:"variableValueList"`
	Version             string          `json:"version"`
	VersionID           string          `json:"versionId"`
	WhitelistIDs        string          `json:"whitelistIds"`
	WhlBusiness         string          `json:"whlBusiness"`
}

type VariableValue struct {
	BizChannel           string `json:"bizChannel"`
	VariableDefaultValue string `json:"variableDefaultValue"`
	VariableDescribe     string `json:"variableDescribe"`
	VariableKey          string `json:"variableKey"`
	VariableName         string `json:"variableName"`
	VariableStructure    string `json:"variableStructure"`
	VariableType         string `json:"variableType"`
}

// FalconAPIResponse represents the API response from Falcon platform
type FalconAPIResponse struct {
	Header APIHeader `json:"header"`
	Body   APIBody   `json:"body"`
}

type APIHeader struct {
	ICIFID      interface{} `json:"iCIFID"`
	ECIFID      interface{} `json:"eCIFID"`
	ErrorCode   string      `json:"errorCode"`
	ErrorMsg    string      `json:"errorMsg"`
	Encry       interface{} `json:"encry"`
	TransCode   interface{} `json:"transCode"`
	Channel     interface{} `json:"channel"`
	ChannelDate interface{} `json:"channelDate"`
	ChannelTime interface{} `json:"channelTime"`
	ChannelFlow interface{} `json:"channelFlow"`
	Type        interface{} `json:"type"`
	TransID     interface{} `json:"transId"`
}

type APIBody struct {
	CardList   []FalconCard `json:"cardList"`
	ErrorCode  string       `json:"errorCode"`
	ErrorMsg   string       `json:"errorMsg"`
	PageNo     string       `json:"pageNo"`
	PageSize   string       `json:"pageSize"`
	TotalNums  string       `json:"totalNums"`
	TotalPages string       `json:"totalPages"`
}

// CardParam represents card parameter information
type CardParam struct {
	ParamID         string      `json:"paramId"`
	ParamName       string      `json:"paramName"`
	ParamType       string      `json:"paramType"`
	ParamDesc       string      `json:"paramDesc"`
	IsRequired      string      `json:"isRequired"`
	BizChannel      string      `json:"bizChannel,omitempty"`
	SassAppID       string      `json:"sassAppId,omitempty"`
	SassWorkspaceID string      `json:"sassWorkspaceId,omitempty"`
	Children        []CardParam `json:"children,omitempty"`
}

// CardDetailResponse represents the card detail API response
type CardDetailResponse struct {
	Header APIHeader      `json:"header"`
	Body   CardDetailBody `json:"body"`
}

type CardDetailBody struct {
	CardID         string      `json:"cardId"`
	CardName       string      `json:"cardName"`
	CardPicURL     string      `json:"cardPicUrl"`
	Code           string      `json:"code"`
	ErrorCode      string      `json:"errorCode"`
	ErrorMsg       string      `json:"errorMsg"`
	MainURL        string      `json:"mainUrl"`
	ParamList      []CardParam `json:"paramList"`
	SkeletonScreen string      `json:"skeletonScreen"`
	Version        string      `json:"version"`
}

// Config implements NodeAdaptor and NodeBuilder interfaces
type Config struct {
	APIEndpoint    string                 `json:"api_endpoint,omitempty"`
	Timeout        int                    `json:"timeout,omitempty"` // timeout in seconds
	SelectedCard   map[string]interface{} `json:"selected_card,omitempty"`   // ÂâçÁ´ØÈÄâÊã©ÁöÑÂç°Áâá‰ø°ÊÅØ
	SelectedCardID string                 `json:"selected_card_id,omitempty"` // ÈÄâÊã©ÁöÑÂç°ÁâáID
}

// Adapt implements NodeAdaptor interface
func (c *Config) Adapt(ctx context.Context, n *vo.Node, opts ...nodes.AdaptOption) (*schema.NodeSchema, error) {
	if n == nil {
		return nil, fmt.Errorf("node cannot be nil")
	}

	var name string
	if n.Data != nil && n.Data.Meta != nil {
		name = n.Data.Meta.Title
	}

	// üö® Ë∞ÉËØïÔºöÊâìÂç∞ÂâçÁ´Ø‰º†Êù•ÁöÑËäÇÁÇπÊï∞ÊçÆ
	fmt.Printf("üîç [CardSelector Adapt] Processing node: %s\n", n.ID)
	if n.Data != nil {
		dataBytes, _ := sonic.Marshal(n.Data)
		fmt.Printf("üîç [CardSelector Adapt] Node data: %s\n", string(dataBytes))
	}

	// Parse configuration data from node data (not just inputs)
	if n.Data != nil {
		// Try to extract from the raw data structure
		dataBytes, err := sonic.Marshal(n.Data)
		if err == nil {
			var dataMap map[string]interface{}
			if err := sonic.Unmarshal(dataBytes, &dataMap); err == nil {
				fmt.Printf("üîç [CardSelector Adapt] Parsed dataMap: %+v\n", dataMap)
				
				// Look for snake_case or camelCase variants in the top level
				if val, ok := dataMap["selected_card"]; ok {
					if cardMap, ok := val.(map[string]interface{}); ok {
						c.SelectedCard = cardMap
						fmt.Printf("‚úÖ [CardSelector Adapt] Found selected_card: %+v\n", cardMap)
					}
				}
				if val, ok := dataMap["selected_card_id"]; ok {
					if cardID, ok := val.(string); ok {
						c.SelectedCardID = cardID
						fmt.Printf("‚úÖ [CardSelector Adapt] Found selected_card_id: %s\n", cardID)
					}
				}
				
				// Ê£ÄÊü• cardSelectorParams
				if val, ok := dataMap["cardSelectorParams"]; ok {
					if params, ok := val.(map[string]interface{}); ok {
						fmt.Printf("‚úÖ [CardSelector Adapt] Found cardSelectorParams: %+v\n", params)
						
						if card, ok := params["selectedCard"]; ok {
							if cardMap, ok := card.(map[string]interface{}); ok {
								c.SelectedCard = cardMap
								fmt.Printf("‚úÖ [CardSelector Adapt] Set selectedCard from params: %+v\n", cardMap)
							}
						}
						if cardId, ok := params["selectedCardId"]; ok {
							if cardID, ok := cardId.(string); ok {
								c.SelectedCardID = cardID
								fmt.Printf("‚úÖ [CardSelector Adapt] Set selectedCardId from params: %s\n", cardID)
							}
						}
					}
				}
			}
		}
	}
	
	fmt.Printf("üîç [CardSelector Adapt] Final config - SelectedCard: %+v, SelectedCardID: %s\n", c.SelectedCard, c.SelectedCardID)

	ns := &schema.NodeSchema{
		Key:     vo.NodeKey(n.ID),
		Type:    entity.NodeTypeCardSelector,
		Name:    name,
		Configs: c,
	}

	// ËÆæÁΩÆËæìÂÖ•Â≠óÊÆµÁ±ªÂûãÂíåÊò†Â∞Ñ‰ø°ÊÅØ
	if err := convert.SetInputsForNodeSchema(n, ns); err != nil {
		return nil, err
	}

	// ËÆæÁΩÆËæìÂá∫Â≠óÊÆµÁ±ªÂûã‰ø°ÊÅØ
	if err := convert.SetOutputTypesForNodeSchema(n, ns); err != nil {
		return nil, err
	}

	return ns, nil
}

// Build implements NodeBuilder interface
func (c *Config) Build(ctx context.Context, ns *schema.NodeSchema, opts ...schema.BuildOption) (any, error) {
	timeout := 30 // default timeout 30 seconds
	if c.Timeout > 0 {
		timeout = c.Timeout
	}

	fmt.Printf("üîç [CardSelector Build] Building node with config - SelectedCard: %+v, SelectedCardID: %s\n", c.SelectedCard, c.SelectedCardID)

	cardSelector := &CardSelector{
		apiEndpoint:    c.APIEndpoint,
		timeout:        timeout,
		selectedCard:   c.SelectedCard,
		selectedCardID: c.SelectedCardID,
	}

	fmt.Printf("üîç [CardSelector Build] Created CardSelector instance: %+v\n", cardSelector)
	
	return cardSelector, nil
}

// CardSelector is the actual node implementation
type CardSelector struct {
	apiEndpoint    string
	timeout        int
	selectedCard   map[string]interface{} // ÈÖçÁΩÆÁöÑÈÄâÊã©Âç°Áâá‰ø°ÊÅØ
	selectedCardID string                 // ÈÖçÁΩÆÁöÑÈÄâÊã©Âç°ÁâáID
}

// Invoke implements InvokableNode interface
func (cs *CardSelector) Invoke(ctx context.Context, input map[string]any) (map[string]any, error) {
	// üö® Ë∞ÉËØï‰ø°ÊÅØÔºöÊâìÂç∞Êé•Êî∂Âà∞ÁöÑËæìÂÖ•Êï∞ÊçÆ
	fmt.Printf("üîç [CardSelector Debug] Received input keys: %v\n", getMapKeys(input))
	fmt.Printf("üîç [CardSelector Debug] Full input: %+v\n", input)
	fmt.Printf("üîç [CardSelector Debug] cs.selectedCard: %+v\n", cs.selectedCard)
	fmt.Printf("üîç [CardSelector Debug] cs.selectedCardID: %s\n", cs.selectedCardID)
	
	// Ê£ÄÊü•ËøêË°åÊó∂ËæìÂÖ•‰∏≠ÁöÑÂÖ≥ÈîÆÂ≠óÊÆµ
	if selectedCardID, ok := input[InputKeySelectedCardID]; ok {
		fmt.Printf("‚úÖ [CardSelector Debug] Found selected_card_id in input: %v\n", selectedCardID)
	} else {
		fmt.Printf("‚ùå [CardSelector Debug] selected_card_id NOT found in input\n")
	}
	
	if selectedCard, ok := input[InputKeySelectedCard]; ok {
		fmt.Printf("‚úÖ [CardSelector Debug] Found selected_card in input: %v\n", selectedCard)
	} else {
		fmt.Printf("‚ùå [CardSelector Debug] selected_card NOT found in input\n")
	}

	// ÊúÄÈ´ò‰ºòÂÖàÁ∫ßÔºö‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÈÄâÊã©Âç°Áâá‰ø°ÊÅØÔºàÂâçÁ´ØÂ∑≤ÈÖçÁΩÆÔºâ
	if cs.selectedCard != nil && len(cs.selectedCard) > 0 {
		card := &FalconCard{}
		if cardId, exists := cs.selectedCard["cardId"]; exists {
			if id, ok := cardId.(string); ok {
				card.CardID = id
			}
		}
		if cardName, exists := cs.selectedCard["cardName"]; exists {
			if name, ok := cardName.(string); ok {
				card.CardName = name
			}
		}
		if code, exists := cs.selectedCard["code"]; exists {
			if c, ok := code.(string); ok {
				card.Code = c
			}
		}

		if card.CardID != "" && card.CardName != "" {
			templateResponse := cs.generateTemplateResponse(card, input)
			return map[string]any{
				OutputKeySelectedCard: map[string]any{
					"id":          card.CardID,
					"name":        card.CardName,
					"description": card.Code,
					"category":    card.CardClassID,
				},
				OutputKeyCardID:           card.CardID,
				OutputKeyCardName:         card.CardName,
				OutputKeyCardDesc:         card.Code,
				OutputKeyTemplateResponse: templateResponse,
			}, nil
		}
	}

	// Ê¨°‰ºòÂÖàÁ∫ßÔºö‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÈÄâÊã©Âç°ÁâáID
	if cs.selectedCardID != "" {
		card, err := cs.fetchCardByID(ctx, cs.selectedCardID)
		if err == nil {
			templateResponse := cs.generateTemplateResponse(card, input)
			return map[string]any{
				OutputKeySelectedCard: map[string]any{
					"id":          card.CardID,
					"name":        card.CardName,
					"description": card.Code,
					"category":    card.CardClassID,
				},
				OutputKeyCardID:           card.CardID,
				OutputKeyCardName:         card.CardName,
				OutputKeyCardDesc:         card.Code,
				OutputKeyTemplateResponse: templateResponse,
			}, nil
		}
	}

	// Á¨¨‰∏â‰ºòÂÖàÁ∫ßÔºöÊ£ÄÊü•ËøêË°åÊó∂‰º†ÈÄíÁöÑÂÆåÊï¥Âç°Áâá‰ø°ÊÅØ
	if selectedCardData, ok := input[InputKeySelectedCard]; ok {
		if cardMap, ok := selectedCardData.(map[string]interface{}); ok {
			// ‰ªéÂâçÁ´Ø‰º†ÈÄíÁöÑÂç°Áâá‰ø°ÊÅØÊûÑÂª∫FalconCard
			card := &FalconCard{}
			if cardId, exists := cardMap["cardId"]; exists {
				if id, ok := cardId.(string); ok {
					card.CardID = id
				}
			}
			if cardName, exists := cardMap["cardName"]; exists {
				if name, ok := cardName.(string); ok {
					card.CardName = name
				}
			}
			if code, exists := cardMap["code"]; exists {
				if c, ok := code.(string); ok {
					card.Code = c
				}
			}

			// Â¶ÇÊûúÂç°Áâá‰ø°ÊÅØÂÆåÊï¥ÔºåÁõ¥Êé•‰ΩøÁî®
			if card.CardID != "" && card.CardName != "" && card.Code != "" {
				// ÁîüÊàêÊ®°ÊùøËæìÂá∫ÁªìÊûÑ
				templateResponse := cs.generateTemplateResponse(card, input)

				return map[string]any{
					OutputKeySelectedCard: map[string]any{
						"id":          card.CardID,
						"name":        card.CardName,
						"description": card.Code,
						"category":    card.CardClassID,
					},
					OutputKeyCardID:           card.CardID,
					OutputKeyCardName:         card.CardName,
					OutputKeyCardDesc:         card.Code,
					OutputKeyTemplateResponse: templateResponse,
				}, nil
			}
		}
	}

	// Â¶ÇÊûúÊ≤°ÊúâÂÆåÊï¥ÁöÑÂç°Áâá‰ø°ÊÅØÔºåÊ£ÄÊü•ÊòØÂê¶ÊúâÈÄâÂÆöÁöÑÂç°ÁâáIDÔºåÈÄöËøáAPIËé∑Âèñ
	if selectedCardID, ok := input[InputKeySelectedCardID].(string); ok && selectedCardID != "" {
		card, err := cs.fetchCardByID(ctx, selectedCardID)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch selected card: %w", err)
		}

		// ÁîüÊàêÊ®°ÊùøËæìÂá∫ÁªìÊûÑ
		templateResponse := cs.generateTemplateResponse(card, input)

		return map[string]any{
			OutputKeySelectedCard: map[string]any{
				"id":          card.CardID,
				"name":        card.CardName,
				"description": card.Code,
				"category":    card.CardClassID,
			},
			OutputKeyCardID:           card.CardID,
			OutputKeyCardName:         card.CardName,
			OutputKeyCardDesc:         card.Code,
			OutputKeyTemplateResponse: templateResponse,
		}, nil
	}

	// Â¶ÇÊûúÊ≤°ÊúâÈÄâÂÆöÁöÑÂç°ÁâáIDÔºåÂàôËøõË°åÊêúÁ¥¢
	searchKeyword := ""
	if keyword, ok := input[InputKeySearchKeyword].(string); ok {
		searchKeyword = keyword
	}

	// Â§ÑÁêÜÂç°ÁâáÁ≠õÈÄâÊù°‰ª∂
	filters := make(map[string]any)
	if filterData, ok := input[InputKeyCardFilters]; ok {
		if filterMap, ok := filterData.(map[string]any); ok {
			filters = filterMap
		}
	}

	// Â¶ÇÊûúÊ≤°ÊúâÊêúÁ¥¢Êù°‰ª∂‰∏îAPIÁ´ØÁÇπÊú™ÈÖçÁΩÆÔºåËøîÂõûÁ©∫ÁªìÊûú
	if searchKeyword == "" && len(filters) == 0 && cs.apiEndpoint == "" {
		fmt.Printf("üìç [CardSelector Debug] Returning empty search results (no conditions)\n")
		return map[string]any{
			OutputKeyCards: []map[string]any{},
			OutputKeyCount: 0,
		}, nil
	}

	fmt.Printf("üìç [CardSelector Debug] Calling searchCardsFromAPI with keyword='%s', filters=%v\n", searchKeyword, filters)
	
	// Ë∞ÉÁî®ÁåéÈπ∞Âπ≥Âè∞APIËé∑ÂèñÂç°Áâá
	cards, err := cs.searchCardsFromAPI(ctx, searchKeyword, filters)
	if err != nil {
		fmt.Printf("‚ùå [CardSelector Debug] searchCardsFromAPI failed: %v\n", err)
		return nil, fmt.Errorf("failed to search cards from API: %w", err)
	}

	fmt.Printf("üìç [CardSelector Debug] searchCardsFromAPI returned %d cards\n", len(cards))

	// ÂáÜÂ§áËæìÂá∫ÁªìÊûú
	cardsOutput := make([]map[string]any, len(cards))
	for i, card := range cards {
		cardsOutput[i] = map[string]any{
			"id":          card.CardID,
			"name":        card.CardName,
			"description": card.Code,
			"category":    card.CardClassID,
		}
	}

	result := map[string]any{
		OutputKeyCards: cardsOutput,
		OutputKeyCount: len(cards),
	}

	// Â¶ÇÊûúÂè™Êúâ‰∏ÄÂº†Âç°ÁâáÔºåËá™Âä®ÈÄâÊã©ÂÆÉ
	if len(cards) == 1 {
		card := cards[0]
		result[OutputKeySelectedCard] = cardsOutput[0]
		result[OutputKeyCardID] = card.CardID
		result[OutputKeyCardName] = card.CardName
		result[OutputKeyCardDesc] = card.Code
		
		// ÁîüÊàêÊ®°ÊùøËæìÂá∫ÁªìÊûÑ
		templateResponse := cs.generateTemplateResponse(&card, input)
		result[OutputKeyTemplateResponse] = templateResponse
	}

	return result, nil
}

// searchCardsFromAPI Ë∞ÉÁî®ÁåéÈπ∞Âπ≥Âè∞APIÊêúÁ¥¢Âç°Áâá
func (cs *CardSelector) searchCardsFromAPI(ctx context.Context, searchKeyword string, filters map[string]any) ([]FalconCard, error) {
	if cs.apiEndpoint == "" {
		return nil, fmt.Errorf("API endpoint not configured")
	}

	// ÊûÑÂª∫APIËØ∑Ê±Ç‰Ωì
	requestBody := FalconAPIRequest{
		Body: FalconRequestBody{
			AgentID:             "",
			ApplyScene:          "",
			CardClassID:         "",
			CardCode:            "",
			CardID:              "",
			CardName:            "",
			CardPicURL:          "",
			Channel:             "",
			Code:                "",
			CreateTime:          "",
			CreatedBy:           true,
			GreyConfigInfo:      "",
			GreyNum:             "",
			ID:                  "",
			IsAdd:               "",
			JSFileURL:           "",
			MainURL:             "",
			Memo:                "",
			ModuleName:          "",
			PageNo:              "1",
			PageSize:            "50",
			PicURL:              "",
			Platform:            "",
			PlatformStatus:      "",
			PlatformValue:       "",
			PreviewSchema:       "",
			PublishMode:         "",
			PublishStatus:       "",
			PublishType:         "",
			RealGreyEndtime:     "",
			ResourceType:        "",
			SassAppID:           "",
			SassWorkspaceID:     "",
			SchemaValue:         "",
			SearchValue:         searchKeyword,
			ServiceModuleID:     "",
			ServiceName:         "",
			SkeletonScreen:      "",
			SoLib:               "",
			StaticMemo:          "",
			StaticType:          "",
			StaticVersion:       "",
			TaskID:              "",
			TaskStatus:          "",
			TemplateID:          "",
			TemplateName:        "",
			TemplateSchemaValue: "",
			UnzipPath:           "",
			UserID:              "",
			VariableValueList: []VariableValue{
				{
					BizChannel:           "",
					VariableDefaultValue: "",
					VariableDescribe:     "",
					VariableKey:          "",
					VariableName:         "",
					VariableStructure:    "",
					VariableType:         "",
				},
			},
			Version:      "",
			VersionID:    "",
			WhitelistIDs: "",
			WhlBusiness:  "",
		},
	}

	// Â∫èÂàóÂåñËØ∑Ê±Ç‰Ωì
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %w", err)
	}

	// Ëá™Âä®ÊãºÊé•Âç°ÁâáÂàóË°®Êé•Âè£Ë∑ØÂæÑ
	listAPIURL := cs.apiEndpoint
	if listAPIURL == "" {
		listAPIURL = "http://10.10.10.208:8500/aop-web"
	}
	if !strings.HasSuffix(listAPIURL, "/IDC10030.do") {
		listAPIURL = strings.TrimSuffix(listAPIURL, "/") + "/IDC10030.do"
	}

	// ÂàõÂª∫HTTPËØ∑Ê±Ç
	req, err := http.NewRequestWithContext(ctx, "POST", listAPIURL, strings.NewReader(string(jsonData)))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// ËÆæÁΩÆËØ∑Ê±ÇÂ§¥
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Request-Origin", "SwaggerBootstrapUi")
	req.Header.Set("Accept", "*/*")

	// ÂàõÂª∫HTTPÂÆ¢Êà∑Á´ØÂπ∂ËÆæÁΩÆË∂ÖÊó∂
	client := &http.Client{
		Timeout: time.Duration(cs.timeout) * time.Second,
	}

	// ÂèëÈÄÅËØ∑Ê±Ç
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	// Ê£ÄÊü•ÂìçÂ∫îÁä∂ÊÄÅ
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	// Ëß£ÊûêÂìçÂ∫î
	var apiResp FalconAPIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Ê£ÄÊü•APIÂìçÂ∫îÁ†Å
	if apiResp.Header.ErrorCode != "0" {
		return nil, fmt.Errorf("API returned error: %s (code: %s)", apiResp.Header.ErrorMsg, apiResp.Header.ErrorCode)
	}

	return apiResp.Body.CardList, nil
}

// fetchCardByID Ê†πÊçÆIDËé∑ÂèñÁâπÂÆöÂç°Áâá‰ø°ÊÅØ
func (cs *CardSelector) fetchCardByID(ctx context.Context, cardID string) (*FalconCard, error) {
	if cs.apiEndpoint == "" {
		return nil, fmt.Errorf("API endpoint not configured")
	}

	// ÊûÑÂª∫Âç°ÁâáËØ¶ÊÉÖAPIËØ∑Ê±Ç‰Ωì
	requestBody := FalconAPIRequest{
		Body: FalconRequestBody{
			AgentID:             "",
			ApplyScene:          "",
			CardClassID:         "",
			CardCode:            "",
			CardID:              cardID, // ËÆæÁΩÆË¶ÅÊü•ËØ¢ÁöÑÂç°ÁâáID
			CardName:            "",
			CardPicURL:          "",
			Channel:             "",
			Code:                "",
			CreateTime:          "",
			CreatedBy:           true,
			GreyConfigInfo:      "",
			GreyNum:             "",
			ID:                  "",
			IsAdd:               "",
			JSFileURL:           "",
			MainURL:             "",
			Memo:                "",
			ModuleName:          "",
			PageNo:              "",
			PageSize:            "",
			PicURL:              "",
			Platform:            "",
			PlatformStatus:      "",
			PlatformValue:       "",
			PreviewSchema:       "",
			PublishMode:         "",
			PublishStatus:       "",
			PublishType:         "",
			RealGreyEndtime:     "",
			ResourceType:        "",
			SassAppID:           "",
			SassWorkspaceID:     "7533521629687578624", // ÂÜôÊ≠ªspaceId
			SchemaValue:         "",
			SearchValue:         "",
			ServiceModuleID:     "",
			ServiceName:         "",
			SkeletonScreen:      "",
			SoLib:               "",
			StaticMemo:          "",
			StaticType:          "",
			StaticVersion:       "",
			TaskID:              "",
			TaskStatus:          "",
			TemplateID:          "",
			TemplateName:        "",
			TemplateSchemaValue: "",
			UnzipPath:           "",
			UserID:              "",
			VariableValueList: []VariableValue{
				{
					BizChannel:           "",
					VariableDefaultValue: "",
					VariableDescribe:     "",
					VariableKey:          "",
					VariableName:         "",
					VariableStructure:    "",
					VariableType:         "",
				},
			},
			Version:      "",
			VersionID:    "",
			WhitelistIDs: "",
			WhlBusiness:  "",
		},
	}

	// Â∫èÂàóÂåñËØ∑Ê±Ç‰Ωì
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %w", err)
	}

	// ÊûÑÂª∫Âç°ÁâáËØ¶ÊÉÖAPI URL
	detailAPIURL := cs.apiEndpoint
	if detailAPIURL == "" {
		detailAPIURL = "http://10.10.10.208:8500/aop-web"
	}
	if !strings.HasSuffix(detailAPIURL, "/IDC10025.do") {
		detailAPIURL = strings.TrimSuffix(detailAPIURL, "/") + "/IDC10025.do"
	}

	// ÂàõÂª∫HTTPËØ∑Ê±Ç
	req, err := http.NewRequestWithContext(ctx, "POST", detailAPIURL, strings.NewReader(string(jsonData)))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// ËÆæÁΩÆËØ∑Ê±ÇÂ§¥
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Request-Origin", "SwaggerBootstrapUi")
	req.Header.Set("Accept", "*/*")

	// ÂàõÂª∫HTTPÂÆ¢Êà∑Á´ØÂπ∂ËÆæÁΩÆË∂ÖÊó∂
	client := &http.Client{
		Timeout: time.Duration(cs.timeout) * time.Second,
	}

	// ÂèëÈÄÅËØ∑Ê±Ç
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	// Ê£ÄÊü•ÂìçÂ∫îÁä∂ÊÄÅ
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	// Ëß£ÊûêÂìçÂ∫î
	var apiResp CardDetailResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Ê£ÄÊü•APIÂìçÂ∫îÁ†Å
	if apiResp.Header.ErrorCode != "0" {
		return nil, fmt.Errorf("API returned error: %s (code: %s)", apiResp.Header.ErrorMsg, apiResp.Header.ErrorCode)
	}

	// ÊûÑÂª∫ËøîÂõûÁöÑÂç°Áâá‰ø°ÊÅØ
	card := &FalconCard{
		CardID:     apiResp.Body.CardID,
		CardName:   apiResp.Body.CardName,
		Code:       apiResp.Body.Code,
		CardPicURL: apiResp.Body.CardPicURL,
	}

	return card, nil
}

// fetchCardDetailWithParams Ëé∑ÂèñÂç°ÁâáËØ¶ÊÉÖÂåÖÊã¨ÂèÇÊï∞‰ø°ÊÅØ
func (cs *CardSelector) fetchCardDetailWithParams(ctx context.Context, cardID string) (*CardDetailBody, error) {
	if cs.apiEndpoint == "" {
		return nil, fmt.Errorf("API endpoint not configured")
	}

	// ÊûÑÂª∫Âç°ÁâáËØ¶ÊÉÖAPIËØ∑Ê±Ç‰Ωì
	requestBody := FalconAPIRequest{
		Body: FalconRequestBody{
			CardID:          cardID,
			CreatedBy:       true,
			SassWorkspaceID: "7533521629687578624", // ÂÜôÊ≠ªspaceId
			PageNo:          "",
			PageSize:        "",
			VariableValueList: []VariableValue{
				{
					BizChannel:           "",
					VariableDefaultValue: "",
					VariableDescribe:     "",
					VariableKey:          "",
					VariableName:         "",
					VariableStructure:    "",
					VariableType:         "",
				},
			},
		},
	}

	// Â∫èÂàóÂåñËØ∑Ê±Ç‰Ωì
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %w", err)
	}

	// ÊûÑÂª∫Âç°ÁâáËØ¶ÊÉÖAPI URL
	detailAPIURL := cs.apiEndpoint
	if detailAPIURL == "" {
		detailAPIURL = "http://10.10.10.208:8500/aop-web"
	}
	if !strings.HasSuffix(detailAPIURL, "/IDC10025.do") {
		detailAPIURL = strings.TrimSuffix(detailAPIURL, "/") + "/IDC10025.do"
	}

	// ÂàõÂª∫HTTPËØ∑Ê±Ç
	req, err := http.NewRequestWithContext(ctx, "POST", detailAPIURL, strings.NewReader(string(jsonData)))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// ËÆæÁΩÆËØ∑Ê±ÇÂ§¥
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Request-Origin", "SwaggerBootstrapUi")
	req.Header.Set("Accept", "*/*")

	// ÂàõÂª∫HTTPÂÆ¢Êà∑Á´ØÂπ∂ËÆæÁΩÆË∂ÖÊó∂
	client := &http.Client{
		Timeout: time.Duration(cs.timeout) * time.Second,
	}

	// ÂèëÈÄÅËØ∑Ê±Ç
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	// Ê£ÄÊü•ÂìçÂ∫îÁä∂ÊÄÅ
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	// Ëß£ÊûêÂìçÂ∫î
	var apiResp CardDetailResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Ê£ÄÊü•APIÂìçÂ∫îÁ†Å
	if apiResp.Header.ErrorCode != "0" {
		return nil, fmt.Errorf("API returned error: %s (code: %s)", apiResp.Header.ErrorMsg, apiResp.Header.ErrorCode)
	}

	return &apiResp.Body, nil
}


// SearchCards ÂÖ¨ÂºÄÊñπÊ≥ïÔºöÊêúÁ¥¢Âç°Áâá
func (cs *CardSelector) SearchCards(ctx context.Context, searchKeyword string, filters map[string]any) ([]FalconCard, error) {
	return cs.searchCardsFromAPI(ctx, searchKeyword, filters)
}

// GetCardDetail ÂÖ¨ÂºÄÊñπÊ≥ïÔºöËé∑ÂèñÂç°ÁâáËØ¶ÊÉÖ
func (cs *CardSelector) GetCardDetail(ctx context.Context, cardID string) (*CardDetailBody, error) {
	return cs.fetchCardDetailWithParams(ctx, cardID)
}

// ToCallbackInput ÂÆûÁé∞ CallbackInputConverted Êé•Âè£ÔºåÁî®‰∫éÊ†ºÂºèÂåñËØïËøêË°åËæìÂÖ•
func (cs *CardSelector) ToCallbackInput(ctx context.Context, input map[string]any) (map[string]any, error) {
	result := make(map[string]any)
	
	// ÊòæÁ§∫APIÈÖçÁΩÆ‰ø°ÊÅØ
	if cs.apiEndpoint != "" {
		result["apiEndpoint"] = cs.apiEndpoint
	} else {
		result["apiEndpoint"] = "http://10.10.10.208:8500/aop-web" // ÈªòËÆ§Á´ØÁÇπ
	}
	
	// ÊòæÁ§∫Ë∂ÖÊó∂ÈÖçÁΩÆ
	result["timeout"] = cs.timeout
	
	// Ëé∑ÂèñÂπ∂ÊòæÁ§∫ÂÆåÊï¥ÁöÑÂç°ÁâáËØ¶ÊÉÖ‰ø°ÊÅØ
	var cardDetail *FalconCard
	var cardDetailInfo *CardDetailBody
	
	// ‰ºòÂÖà‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÈÄâÊã©Âç°Áâá‰ø°ÊÅØ
	if cs.selectedCard != nil && len(cs.selectedCard) > 0 {
		cardDetail = &FalconCard{}
		if cardId, exists := cs.selectedCard["cardId"]; exists {
			if id, ok := cardId.(string); ok {
				cardDetail.CardID = id
			}
		}
		if cardName, exists := cs.selectedCard["cardName"]; exists {
			if name, ok := cardName.(string); ok {
				cardDetail.CardName = name
			}
		}
		if code, exists := cs.selectedCard["code"]; exists {
			if c, ok := code.(string); ok {
				cardDetail.Code = c
			}
		}
		
		// Â¶ÇÊûúÊúâÂç°ÁâáIDÔºåËé∑ÂèñÂÆåÊï¥ÁöÑÂç°ÁâáËØ¶ÊÉÖÔºàÂåÖÊã¨ÂèÇÊï∞ÂàóË°®Ôºâ
		if cardDetail.CardID != "" {
			if detail, err := cs.fetchCardDetailWithParams(ctx, cardDetail.CardID); err == nil {
				cardDetailInfo = detail
			}
		}
	}
	
	// Ê¨°‰ºòÂÖàÁ∫ßÔºö‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÈÄâÊã©Âç°ÁâáID
	if cardDetail == nil && cs.selectedCardID != "" {
		if card, err := cs.fetchCardByID(ctx, cs.selectedCardID); err == nil {
			cardDetail = card
			if detail, err := cs.fetchCardDetailWithParams(ctx, cs.selectedCardID); err == nil {
				cardDetailInfo = detail
			}
		}
	}
	
	// Á¨¨‰∏â‰ºòÂÖàÁ∫ßÔºöÊ£ÄÊü•ËøêË°åÊó∂‰º†ÈÄíÁöÑÂÆåÊï¥Âç°Áâá‰ø°ÊÅØÔºàÊù•Ëá™ÊµãËØïË°®ÂçïÔºâ
	if cardDetail == nil {
		if selectedCardData, ok := input["selected_card"]; ok {
			if cardMap, ok := selectedCardData.(map[string]interface{}); ok {
				cardDetail = &FalconCard{}
				if cardId, exists := cardMap["cardId"]; exists {
					if id, ok := cardId.(string); ok {
						cardDetail.CardID = id
					}
				}
				if cardName, exists := cardMap["cardName"]; exists {
					if name, ok := cardName.(string); ok {
						cardDetail.CardName = name
					}
				}
				if code, exists := cardMap["code"]; exists {
					if c, ok := code.(string); ok {
						cardDetail.Code = c
					}
				}
				
				// Ëé∑ÂèñÂÆåÊï¥ÁöÑÂç°ÁâáËØ¶ÊÉÖ
				if cardDetail.CardID != "" {
					if detail, err := cs.fetchCardDetailWithParams(ctx, cardDetail.CardID); err == nil {
						cardDetailInfo = detail
					}
				}
			}
		}
	}
	
	// Á¨¨Âõõ‰ºòÂÖàÁ∫ßÔºöÊ£ÄÊü•ËøêË°åÊó∂‰º†ÈÄíÁöÑÂÆåÊï¥Âç°Áâá‰ø°ÊÅØÔºàÊù•Ëá™ËäÇÁÇπÈÖçÁΩÆÔºâ
	if cardDetail == nil {
		if selectedCardData, ok := input[InputKeySelectedCard]; ok {
			if cardMap, ok := selectedCardData.(map[string]interface{}); ok {
				cardDetail = &FalconCard{}
				if cardId, exists := cardMap["cardId"]; exists {
					if id, ok := cardId.(string); ok {
						cardDetail.CardID = id
					}
				}
				if cardName, exists := cardMap["cardName"]; exists {
					if name, ok := cardName.(string); ok {
						cardDetail.CardName = name
					}
				}
				if code, exists := cardMap["code"]; exists {
					if c, ok := code.(string); ok {
						cardDetail.Code = c
					}
				}
				
				// Ëé∑ÂèñÂÆåÊï¥ÁöÑÂç°ÁâáËØ¶ÊÉÖ
				if cardDetail.CardID != "" {
					if detail, err := cs.fetchCardDetailWithParams(ctx, cardDetail.CardID); err == nil {
						cardDetailInfo = detail
					}
				}
			}
		}
	}
	
	// ÊúÄÂêéÔºöÊ£ÄÊü•ËøêË°åÊó∂‰º†ÈÄíÁöÑÂç°ÁâáID
	if cardDetail == nil {
		if selectedCardID, ok := input[InputKeySelectedCardID].(string); ok && selectedCardID != "" {
			if card, err := cs.fetchCardByID(ctx, selectedCardID); err == nil {
				cardDetail = card
				if detail, err := cs.fetchCardDetailWithParams(ctx, selectedCardID); err == nil {
					cardDetailInfo = detail
				}
			}
		}
	}
	
	// Â¶ÇÊûúÊâæÂà∞‰∫ÜÂç°ÁâáËØ¶ÊÉÖÔºåÊòæÁ§∫ÂÆåÊï¥‰ø°ÊÅØ
	if cardDetail != nil {
		result["selectedCardDetail"] = map[string]any{
			"cardId":      cardDetail.CardID,
			"cardName":    cardDetail.CardName,
			"code":        cardDetail.Code,
			"cardPicURL":  cardDetail.CardPicURL,
		}
		
		// Â¶ÇÊûúÊúâËØ¶ÁªÜÂèÇÊï∞‰ø°ÊÅØÔºå‰πüÂåÖÂê´ËøõÂéª
		if cardDetailInfo != nil {
			result["cardParameters"] = cardDetailInfo.ParamList
			result["cardMainURL"] = cardDetailInfo.MainURL
			result["cardVersion"] = cardDetailInfo.Version
		}
	}
	
	// ÊòæÁ§∫ÊêúÁ¥¢ÂÖ≥ÈîÆËØç
	if searchKeyword, ok := input[InputKeySearchKeyword].(string); ok && searchKeyword != "" {
		result["searchKeyword"] = searchKeyword
	}
	
	// ÊòæÁ§∫Âç°ÁâáÁ≠õÈÄâÊù°‰ª∂
	if cardFilters, ok := input[InputKeyCardFilters]; ok {
		if filterMap, ok := cardFilters.(map[string]any); ok && len(filterMap) > 0 {
			result["cardFilters"] = filterMap
		}
	}
	
	// ÊòæÁ§∫ËæìÂÖ•ÂèÇÊï∞ÂàóË°®ÔºàÂ∑•‰ΩúÊµÅËäÇÁÇπÁöÑËæìÂÖ•ÂèÇÊï∞ÂÆö‰πâÔºâ
	if inputParameters, ok := input[InputKeyInputParameters]; ok {
		result["inputParameters"] = inputParameters
	}
	
	// ÊòæÁ§∫ÂÖ∂‰ªñËøêË°åÊó∂ËæìÂÖ•ÂèÇÊï∞ÔºàÁî®Êà∑Âú®ËØïËøêË°åË°®Âçï‰∏≠ËæìÂÖ•ÁöÑÂèòÈáèÂÄºÔºâ
	variableInputs := make(map[string]any)
	for key, value := range input {
		// Ë∑≥ËøáÁâπÊÆäÁöÑÂÜÖÁΩÆÈîÆÔºåÂè™ÊòæÁ§∫Áî®Êà∑ÂÆö‰πâÁöÑÂèòÈáèÂèÇÊï∞
		if key != "selected_card" && key != InputKeySearchKeyword && key != InputKeyCardFilters && 
		   key != InputKeySelectedCardID && key != InputKeySelectedCard && 
		   key != InputKeyInputParameters {
			variableInputs[key] = value
		}
	}
	if len(variableInputs) > 0 {
		result["variableInputs"] = variableInputs
	}
	
	return result, nil
}

// generateTemplateResponse ÁîüÊàêÊ®°ÊùøËæìÂá∫ÁªìÊûÑÔºåÊåâÁÖßÁî®Êà∑Ë¶ÅÊ±ÇÁöÑÊ®°ÊùøÊ†ºÂºè
func (cs *CardSelector) generateTemplateResponse(card *FalconCard, input map[string]any) map[string]any {
	// ÁîüÊàêdataResponseÔºåÊ†πÊçÆËæìÂÖ•ÂèÇÊï∞ÂíåÂÆûÈôÖÁöÑÂèòÈáèÂÄºËá™Âä®ÈÄÇÈÖç
	dataResponse := make(map[string]any)

	// È¶ñÂÖàÂ∞ùËØï‰ªéËæìÂÖ•ÂèÇÊï∞ÂàóË°®Ëé∑ÂèñÂèÇÊï∞ÂÆö‰πâ
	hasParameters := false
	if inputParameters, ok := input[InputKeyInputParameters]; ok {
		if paramList, ok := inputParameters.([]interface{}); ok {
			for _, param := range paramList {
				if paramMap, ok := param.(map[string]interface{}); ok {
					if paramName, exists := paramMap["name"]; exists {
						if name, ok := paramName.(string); ok && name != "" {
							hasParameters = true
							// Ê£ÄÊü•ÊòØÂê¶ÊúâÂÆûÈôÖÁöÑËæìÂÖ•ÂÄº
							if actualValue, hasValue := input[name]; hasValue {
								dataResponse[name] = actualValue
							} else {
								// ‰ΩøÁî®ÂèòÈáèÂç†‰ΩçÁ¨¶Ê†ºÂºè
								dataResponse[name] = fmt.Sprintf("{%s}", name)
							}
						}
					}
				}
			}
		}
	}

	// Â¶ÇÊûúÊ≤°ÊúâÂÆö‰πâÁöÑËæìÂÖ•ÂèÇÊï∞ÔºåÊ£ÄÊü•ÊâÄÊúâÈùûÁâπÊÆäÈîÆÁöÑËæìÂÖ•‰Ωú‰∏∫ÂèòÈáè
	if !hasParameters {
		for key, value := range input {
			// Ë∑≥ËøáÁâπÊÆäÁöÑÂÜÖÁΩÆÈîÆÔºåÂ∞ÜÂÖ∂‰ªñÈîÆ‰Ωú‰∏∫ÂèòÈáèÂ§ÑÁêÜ
			if key != InputKeySearchKeyword && key != InputKeyCardFilters && 
			   key != InputKeySelectedCardID && key != InputKeySelectedCard && 
			   key != InputKeyInputParameters {
				dataResponse[key] = value
			}
		}
	}

	// Â¶ÇÊûúËøòÊòØÊ≤°Êúâ‰ªª‰ΩïÂèÇÊï∞ÔºåÊèê‰æõÈªòËÆ§ÁöÑÁ§∫‰æãÁªìÊûÑ
	if len(dataResponse) == 0 {
		dataResponse["payeeList"] = "{payeeList}"
	}

	// ÊûÑÂª∫Á¨¶ÂêàË¶ÅÊ±ÇÁöÑÊ®°ÊùøËæìÂá∫ÁªìÊûÑ
	templateResponse := map[string]any{
		"displayResponseType": "TEMPLATE",
		"rawContent":          map[string]any{},  // ÂéüÂßãÂÜÖÂÆπÔºåÈÄöÂ∏∏‰∏∫Á©∫
		"templateId":          card.Code,         // ‰ΩøÁî®Âç°ÁâáÁöÑCode‰Ωú‰∏∫Ê®°ÊùøID
		"templateName":        card.CardName,     // ‰ΩøÁî®Âç°ÁâáÂêçÁß∞‰Ωú‰∏∫Ê®°ÊùøÂêçÁß∞  
		"kvMap":               map[string]any{},  // ÈîÆÂÄºÊò†Â∞ÑÔºåÈÄöÂ∏∏‰∏∫Á©∫
		"dataResponse":        dataResponse,      // Ê†πÊçÆËæìÂÖ•ÂèòÈáèËá™Âä®ÈÄÇÈÖçÁöÑÊï∞ÊçÆÂìçÂ∫î
	}

	return templateResponse
}

// ToCallbackOutput ÂÆûÁé∞ CallbackOutputConverted Êé•Âè£ÔºåÁî®‰∫éÊ†ºÂºèÂåñËØïËøêË°åËæìÂá∫
func (cs *CardSelector) ToCallbackOutput(ctx context.Context, out map[string]any) (*nodes.StructuredCallbackOutput, error) {
	// Ê£ÄÊü•ÊòØÂê¶ÊúâÊ®°ÊùøÂìçÂ∫îÊï∞ÊçÆ
	if templateResponse, ok := out[OutputKeyTemplateResponse]; ok {
		if templateMap, ok := templateResponse.(map[string]any); ok {
			// ËØïËøêË°åÊó∂Áõ¥Êé•ËøîÂõûÊ®°ÊùøÂìçÂ∫îÊ†ºÂºèÔºåËøôÊ†∑ÂâçÁ´ØÂèØ‰ª•Ê≠£Á°ÆÊòæÁ§∫
			return &nodes.StructuredCallbackOutput{
				RawOutput: out,         // ‰øùÁïôÂéüÂßãËæìÂá∫
				Output:    templateMap, // ÊòæÁ§∫ÁöÑËæìÂá∫‰∏∫Ê®°ÊùøÂìçÂ∫îÊ†ºÂºè
			}, nil
		}
	}

	// Â¶ÇÊûúÊ≤°ÊúâÊ®°ÊùøÂìçÂ∫îÔºåËøîÂõûÂéüÂßãËæìÂá∫
	return &nodes.StructuredCallbackOutput{
		RawOutput: out,
		Output:    out,
	}, nil
}

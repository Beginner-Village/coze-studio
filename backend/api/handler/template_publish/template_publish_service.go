/*
 * Copyright 2025 coze-dev Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by hertz generator.

package template_publish

import (
	"context"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"math/rand"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	template_publish "github.com/coze-dev/coze-studio/backend/api/model/template_publish"
	"github.com/coze-dev/coze-studio/backend/application/base/ctxutil"
	"github.com/coze-dev/coze-studio/backend/application/template"
	"github.com/coze-dev/coze-studio/backend/application/upload"
	"github.com/coze-dev/coze-studio/backend/pkg/errorx"
	"github.com/coze-dev/coze-studio/backend/pkg/lang/ptr"
	"github.com/coze-dev/coze-studio/backend/types/errno"
)

// PublishAsTemplate .
// @router /api/template/publish [POST]
func PublishAsTemplate(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.PublishAsTemplateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.PublishAsTemplate(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetMyTemplateList .
// @router /api/template/my-list [GET]
func GetMyTemplateList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.GetMyTemplateListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.GetMyTemplateList(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// DeleteTemplate .
// @router /api/template/{template_id} [DELETE]
func DeleteTemplate(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.DeleteTemplateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.DeleteTemplate(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// UnpublishTemplate .
// @router /api/template/unpublish [POST]
func UnpublishTemplate(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.UnpublishTemplateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.UnpublishTemplate(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// CheckPublishStatus .
// @router /api/template/check-status [GET]
func CheckPublishStatus(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.CheckPublishStatusRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.CheckPublishStatus(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

func createSecret(uid int64, fileType string) string {
	num := 10
	input := fmt.Sprintf("upload_%d_Ma*9)fhi_%d_gou_%s_rand_%d", uid, time.Now().Unix(), fileType, rand.Intn(100000))
	// Do md5, take the first 20,//mapIntToBase62 map the number to Base62
	hash := sha256.Sum256([]byte(fmt.Sprintf("%s", input)))
	hashString := base64.StdEncoding.EncodeToString(hash[:])
	if len(hashString) > num {
		hashString = hashString[:num]
	}

	result := ""
	for _, char := range hashString {
		index := int(char) % 62
		result += string(baseWord[index])
	}
	return result
}

const baseWord = "1Aa2Bb3Cc4Dd5Ee6Ff7Gg8Hh9Ii0JjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"

// UploadTemplateIcon .
// @router /api/template/upload_icon [POST]
func UploadTemplateIcon(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.UploadTemplateIconRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 解码base64文件内容
	fileContent, err := base64.StdEncoding.DecodeString(req.Data)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 获取用户ID
	userID := ctxutil.GetUIDFromCtx(ctx)
	if userID == nil {
		c.String(consts.StatusUnauthorized, errorx.New(errno.ErrUploadPermissionCode, errorx.KV("msg", "session required")).Error())
		return
	}

	// 生成文件名
	secret := createSecret(ptr.From(userID), req.FileHead.FileType)
	fileName := fmt.Sprintf("%d_%d_%s.%s", ptr.From(userID), time.Now().UnixNano(), secret, req.FileHead.FileType)
	objectName := fmt.Sprintf("%s/%s", req.FileHead.BizType.String(), fileName)

	// 上传文件
	uploadResp, err := upload.SVC.UploadFile(ctx, fileContent, objectName)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	// 构造响应
	resp := &template_publish.UploadTemplateIconResponse{
		Data: &template_publish.TemplateIconData{
			UploadURL: uploadResp.Data.UploadURL,
			UploadURI: uploadResp.Data.UploadURI,
		},
		Code: 0,
		Msg:  "success",
	}

	c.JSON(consts.StatusOK, resp)
}

// PublishToStore .
// @router /api/template/store/publish [POST]
func PublishToStore(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.PublishToStoreRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.PublishToStore(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetStoreTemplateList .
// @router /api/template/store/list [GET]
func GetStoreTemplateList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.GetStoreTemplateListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.GetStoreTemplateList(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// UnpublishFromStore .
// @router /api/template/store/unpublish [POST]
func UnpublishFromStore(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.UnpublishFromStoreRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.UnpublishFromStore(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// CheckStorePublishStatus .
// @router /api/template/store/check-status [GET]
func CheckStorePublishStatus(ctx context.Context, c *app.RequestContext) {
	var err error
	var req template_publish.CheckStorePublishStatusRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := template.ApplicationSVC.CheckStorePublishStatus(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

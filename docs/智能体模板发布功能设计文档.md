# 智能体模板发布功能设计文档

## 📋 项目概述

**功能目标**: 允许用户在发布智能体时，选择将其发布为模板，供其他用户使用

**技术可行性**: ✅ 完全可行，基于现有架构无需大改动

**实施策略**: 分三个阶段渐进式实现

## 🔍 现有架构分析

### 数据结构完整性
- ✅ `template` 表已存在，支持存储模板数据
- ✅ `single_agent_draft` 和 `single_agent_version` 有完整的智能体数据
- ✅ 对象存储已支持图片资源管理

### API架构成熟度
- ✅ 已有完整的模板展示API (`/api/marketplace/product/list`)
- ✅ 智能体发布流程成熟 (`PublishAgent`)
- ✅ 支持Thrift IDL代码生成

### 前端UI基础
- ✅ 智能体发布页面已存在
- ✅ 模板展示页面已实现

## 🎯 第一阶段实现方案（基础功能）

### 1. IDL接口定义

**文件位置**: `idl/template/template_publish.thrift`

```thrift
namespace go template_publish

struct PublishAsTemplateRequest {
    1: required i64 agent_id (api.body="agent_id")
    2: required string title (api.body="title") 
    3: optional string description (api.body="description")
    4: optional i64 category_id (api.body="category_id")
    5: optional list<string> labels (api.body="labels")
    6: required bool is_public (api.body="is_public")
    7: optional string cover_uri (api.body="cover_uri") // 封面图片URI
}

struct PublishAsTemplateResponse {
    1: required i64 template_id
    2: required string status // "pending", "approved", "published" 
    253: required i32 code
    254: required string msg
}

struct GetMyTemplateListRequest {
    1: optional i32 page_num (api.query="page_num")
    2: optional i32 page_size (api.query="page_size")
}

struct GetMyTemplateListResponse {
    1: required list<TemplateInfo> templates
    2: required bool has_more
    3: required i32 total
    253: required i32 code
    254: required string msg
}

struct TemplateInfo {
    1: required i64 template_id
    2: required i64 agent_id
    3: required string title
    4: optional string description
    5: required string status
    6: required i64 created_at
    7: optional i64 heat // 使用次数
}

struct DeleteTemplateRequest {
    1: required i64 template_id (api.path="template_id")
}

struct DeleteTemplateResponse {
    253: required i32 code
    254: required string msg
}

service TemplatePublishService {
    PublishAsTemplateResponse PublishAsTemplate(1: PublishAsTemplateRequest req) 
        (api.post="/api/template/publish")
    
    // 获取我的模板列表
    GetMyTemplateListResponse GetMyTemplateList(1: GetMyTemplateListRequest req)
        (api.get="/api/template/my-list")
        
    // 删除模板
    DeleteTemplateResponse DeleteTemplate(1: DeleteTemplateRequest req)
        (api.delete="/api/template/{template_id}")
}
```

### 2. 后端实现

#### 核心业务逻辑

**文件位置**: `backend/application/template/publish.go`

```go
package template

import (
    "context"
    "fmt"
    "time"
    
    "github.com/coze-dev/coze-studio/backend/api/model/template/template_publish"
    "github.com/coze-dev/coze-studio/backend/application/base/ctxutil"
    "github.com/coze-dev/coze-studio/backend/domain/template/entity"
    "github.com/coze-dev/coze-studio/backend/pkg/lang/ptr"
    "github.com/coze-dev/coze-studio/backend/pkg/logs"
    "github.com/coze-dev/coze-studio/backend/types/consts"
)

func (t *ApplicationService) PublishAsTemplate(ctx context.Context, req *template_publish.PublishAsTemplateRequest) (*template_publish.PublishAsTemplateResponse, error) {
    // 1. 验证智能体权限
    agent, err := t.validateAgentAccess(ctx, req.AgentID)
    if err != nil {
        return nil, err
    }
    
    // 2. 检查是否已发布
    exists, err := t.templateRepo.ExistsByAgentID(ctx, req.AgentID)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, errorx.New(errno.ErrTemplateAlreadyExistsCode, errorx.KV("msg", "template already published"))
    }
    
    // 3. 转换数据格式
    templateData, err := t.convertAgentToTemplate(ctx, agent, req)
    if err != nil {
        return nil, err
    }
    
    // 4. 保存模板数据
    templateID, err := t.templateRepo.Create(ctx, templateData)
    if err != nil {
        return nil, err
    }
    
    // 5. 处理封面图片
    if req.CoverUri != nil {
        err = t.processCoverImage(ctx, templateID, *req.CoverUri)
        if err != nil {
            logs.CtxWarnf(ctx, "process cover image failed: %v", err)
        }
    }
    
    return &template_publish.PublishAsTemplateResponse{
        TemplateID: templateID,
        Status: "published", // 第一阶段直接发布，不需审核
        Code: 0,
        Msg: "success",
    }, nil
}

func (t *ApplicationService) validateAgentAccess(ctx context.Context, agentID int64) (*entity.SingleAgent, error) {
    userID := ctxutil.MustGetUIDFromCtx(ctx)
    
    // 通过SingleAgent应用服务验证权限
    agent, err := t.singleAgentSVC.ValidateAgentDraftAccess(ctx, agentID)
    if err != nil {
        return nil, err
    }
    
    // 检查是否已发布
    if !agent.HasPublished() {
        return nil, errorx.New(errno.ErrAgentNotPublishedCode, errorx.KV("msg", "agent must be published first"))
    }
    
    return agent, nil
}

func (t *ApplicationService) convertAgentToTemplate(ctx context.Context, agent *entity.SingleAgent, req *template_publish.PublishAsTemplateRequest) (*model.Template, error) {
    userID := ctxutil.MustGetUIDFromCtx(ctx)
    
    // 获取用户信息
    userInfo, err := t.getUserInfo(ctx, userID)
    if err != nil {
        return nil, err
    }
    
    // 构建 meta_info JSON 数据
    metaInfo := map[string]interface{}{
        "id": fmt.Sprintf("%d", agent.AgentID),
        "name": req.Title,
        "entity_id": fmt.Sprintf("%d", agent.AgentID),
        "entity_type": 21, // BotTemplate
        "entity_version": fmt.Sprintf("%d", time.Now().Unix()),
        "description": ptr.SafeDeref(req.Description),
        "icon_url": agent.IconURI, // 使用智能体的图标
        "is_template": true,
        "is_official": false, // 用户发布的不是官方模板
        "is_free": true,
        "status": 1, // Listed
        "listed_at": fmt.Sprintf("%d", time.Now().Unix()),
        "user_info": map[string]interface{}{
            "user_id": fmt.Sprintf("%d", userID),
            "name": userInfo.Name,
            "avatar_url": userInfo.AvatarURL,
        },
        "labels": req.Labels,
        "heat": 0,
        "favorite_count": 0,
        "is_favorited": false,
    }
    
    // 如果有分类信息
    if req.CategoryId != nil {
        category, err := t.getCategoryInfo(ctx, *req.CategoryId)
        if err == nil {
            metaInfo["category"] = map[string]interface{}{
                "id": fmt.Sprintf("%d", *req.CategoryId),
                "name": category.Name,
            }
        }
    }
    
    // 处理封面信息
    covers := []map[string]interface{}{}
    if req.CoverUri != nil {
        covers = append(covers, map[string]interface{}{
            "uri": *req.CoverUri,
            "url": "", // 将在processCoverImage中处理
        })
    }
    metaInfo["covers"] = covers
    
    return &model.Template{
        AgentID: agent.AgentID,
        SpaceID: consts.TemplateSpaceID, // 999999
        ProductEntityType: 21, // BotTemplate
        MetaInfo: metaInfo,
        Heat: 0,
        CreatedAt: time.Now().UnixMilli(),
    }, nil
}

func (t *ApplicationService) GetMyTemplateList(ctx context.Context, req *template_publish.GetMyTemplateListRequest) (*template_publish.GetMyTemplateListResponse, error) {
    userID := ctxutil.MustGetUIDFromCtx(ctx)
    
    pageNum := ptr.SafeDeref(req.PageNum)
    pageSize := ptr.SafeDerefD(req.PageSize, 20)
    
    filter := &entity.TemplateFilter{
        CreatorID: &userID,
        SpaceID: ptr.Of(int64(consts.TemplateSpaceID)),
    }
    
    pagination := &entity.Pagination{
        Limit: int(pageSize),
        Offset: int(pageNum * pageSize),
    }
    
    templates, total, err := t.templateRepo.List(ctx, filter, pagination, "created_at")
    if err != nil {
        return nil, err
    }
    
    templateInfos := make([]*template_publish.TemplateInfo, 0, len(templates))
    for _, tmpl := range templates {
        info := &template_publish.TemplateInfo{
            TemplateID: tmpl.ID,
            AgentID: tmpl.AgentID,
            Title: tmpl.GetTitle(),
            Description: ptr.Of(tmpl.GetDescription()),
            Status: "published",
            CreatedAt: tmpl.CreatedAt,
            Heat: ptr.Of(tmpl.Heat),
        }
        templateInfos = append(templateInfos, info)
    }
    
    return &template_publish.GetMyTemplateListResponse{
        Templates: templateInfos,
        HasMore: int64(pageNum*pageSize+len(templates)) < total,
        Total: int32(total),
        Code: 0,
        Msg: "success",
    }, nil
}

func (t *ApplicationService) DeleteTemplate(ctx context.Context, req *template_publish.DeleteTemplateRequest) (*template_publish.DeleteTemplateResponse, error) {
    userID := ctxutil.MustGetUIDFromCtx(ctx)
    
    // 验证模板所有权
    template, err := t.templateRepo.GetByID(ctx, req.TemplateID)
    if err != nil {
        return nil, err
    }
    
    if template.CreatorID != userID {
        return nil, errorx.New(errno.ErrTemplatePermissionDeniedCode, errorx.KV("msg", "permission denied"))
    }
    
    // 删除模板
    err = t.templateRepo.Delete(ctx, req.TemplateID)
    if err != nil {
        return nil, err
    }
    
    return &template_publish.DeleteTemplateResponse{
        Code: 0,
        Msg: "success",
    }, nil
}
```

#### Handler实现

**文件位置**: `backend/api/handler/template/template_publish_service.go`

```go
// Code generated by hertz generator.

package template

import (
    "context"
    
    "github.com/cloudwego/hertz/pkg/app"
    "github.com/cloudwego/hertz/pkg/protocol/consts"
    
    template_publish "github.com/coze-dev/coze-studio/backend/api/model/template/template_publish"
    "github.com/coze-dev/coze-studio/backend/application/template"
)

// PublishAsTemplate .
// @router /api/template/publish [POST]
func PublishAsTemplate(ctx context.Context, c *app.RequestContext) {
    var err error
    var req template_publish.PublishAsTemplateRequest
    err = c.BindAndValidate(&req)
    if err != nil {
        c.String(consts.StatusBadRequest, err.Error())
        return
    }

    resp, err := template.ApplicationSVC.PublishAsTemplate(ctx, &req)
    if err != nil {
        c.String(consts.StatusInternalServerError, err.Error())
        return
    }

    c.JSON(consts.StatusOK, resp)
}

// GetMyTemplateList .
// @router /api/template/my-list [GET]
func GetMyTemplateList(ctx context.Context, c *app.RequestContext) {
    var err error
    var req template_publish.GetMyTemplateListRequest
    err = c.BindAndValidate(&req)
    if err != nil {
        c.String(consts.StatusBadRequest, err.Error())
        return
    }

    resp, err := template.ApplicationSVC.GetMyTemplateList(ctx, &req)
    if err != nil {
        c.String(consts.StatusInternalServerError, err.Error())
        return
    }

    c.JSON(consts.StatusOK, resp)
}

// DeleteTemplate .
// @router /api/template/{template_id} [DELETE]
func DeleteTemplate(ctx context.Context, c *app.RequestContext) {
    var err error
    var req template_publish.DeleteTemplateRequest
    err = c.BindAndValidate(&req)
    if err != nil {
        c.String(consts.StatusBadRequest, err.Error())
        return
    }

    resp, err := template.ApplicationSVC.DeleteTemplate(ctx, &req)
    if err != nil {
        c.String(consts.StatusInternalServerError, err.Error())
        return
    }

    c.JSON(consts.StatusOK, resp)
}
```

### 3. 前端实现

#### 模板发布组件

**文件位置**: `frontend/packages/agent-ide/agent-publish/src/components/template-publish-section.tsx`

```typescript
import React, { useState } from 'react';
import { Card, Switch, Input, Select, Form, Tooltip, Tag, Button } from '@coze-arch/coze-design';
import { IconCozInfoCircle } from '@coze-arch/coze-design/icons';
import { I18n } from '@coze-arch/i18n';

interface TemplatePublishData {
  title: string;
  description: string;
  categoryId: number | null;
  labels: string[];
  isPublic: boolean;
  coverUri?: string;
}

interface TemplatePublishSectionProps {
  agentInfo: {
    id: string;
    name: string;
    description: string;
    iconUrl?: string;
  };
  onToggle: (enabled: boolean, data?: TemplatePublishData) => void;
  disabled?: boolean;
}

const CATEGORIES = [
  { value: 1, label: I18n.t('category_education') }, // 学习教育
  { value: 2, label: I18n.t('category_business') },  // 办公商务
  { value: 3, label: I18n.t('category_entertainment') }, // 娱乐休闲
  { value: 4, label: I18n.t('category_life') }, // 生活助手
  { value: 5, label: I18n.t('category_creative') }, // 创意设计
];

export const TemplatePublishSection: React.FC<TemplatePublishSectionProps> = ({
  agentInfo,
  onToggle,
  disabled = false,
}) => {
  const [publishAsTemplate, setPublishAsTemplate] = useState(false);
  const [templateData, setTemplateData] = useState<TemplatePublishData>({
    title: agentInfo.name,
    description: agentInfo.description || '',
    categoryId: null,
    labels: [],
    isPublic: true,
  });

  const [inputLabel, setInputLabel] = useState('');

  const handleToggle = (checked: boolean) => {
    setPublishAsTemplate(checked);
    onToggle(checked, checked ? templateData : undefined);
  };

  const handleDataChange = (newData: Partial<TemplatePublishData>) => {
    const updatedData = { ...templateData, ...newData };
    setTemplateData(updatedData);
    if (publishAsTemplate) {
      onToggle(true, updatedData);
    }
  };

  const handleAddLabel = () => {
    if (inputLabel.trim() && !templateData.labels.includes(inputLabel.trim())) {
      const newLabels = [...templateData.labels, inputLabel.trim()];
      handleDataChange({ labels: newLabels });
      setInputLabel('');
    }
  };

  const handleRemoveLabel = (labelToRemove: string) => {
    const newLabels = templateData.labels.filter(label => label !== labelToRemove);
    handleDataChange({ labels: newLabels });
  };

  return (
    <Card className="template-publish-section">
      <Card.Header className="flex items-center gap-3">
        <Switch
          checked={publishAsTemplate}
          onChange={handleToggle}
          disabled={disabled}
        />
        <span className="text-base font-medium">
          {I18n.t('publish_as_template')}
        </span>
        <Tooltip content={I18n.t('publish_as_template_tooltip')}>
          <IconCozInfoCircle className="text-gray-500" />
        </Tooltip>
      </Card.Header>

      {publishAsTemplate && (
        <Card.Content className="mt-4 space-y-4">
          <Form.Item
            label={I18n.t('template_title')}
            required
          >
            <Input
              value={templateData.title}
              onChange={title => handleDataChange({ title })}
              placeholder={I18n.t('template_title_placeholder')}
              maxLength={50}
            />
          </Form.Item>

          <Form.Item label={I18n.t('template_description')}>
            <Input.TextArea
              value={templateData.description}
              onChange={description => handleDataChange({ description })}
              placeholder={I18n.t('template_description_placeholder')}
              rows={3}
              maxLength={500}
            />
          </Form.Item>

          <Form.Item label={I18n.t('template_category')}>
            <Select
              value={templateData.categoryId}
              onChange={categoryId => handleDataChange({ categoryId })}
              placeholder={I18n.t('select_category')}
              allowClear
            >
              {CATEGORIES.map(category => (
                <Select.Option key={category.value} value={category.value}>
                  {category.label}
                </Select.Option>
              ))}
            </Select>
          </Form.Item>

          <Form.Item label={I18n.t('template_labels')}>
            <div className="space-y-2">
              <div className="flex gap-2">
                <Input
                  value={inputLabel}
                  onChange={setInputLabel}
                  placeholder={I18n.t('add_label_placeholder')}
                  onPressEnter={handleAddLabel}
                  maxLength={20}
                />
                <Button onClick={handleAddLabel} type="secondary">
                  {I18n.t('add')}
                </Button>
              </div>
              {templateData.labels.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {templateData.labels.map(label => (
                    <Tag
                      key={label}
                      closable
                      onClose={() => handleRemoveLabel(label)}
                    >
                      {label}
                    </Tag>
                  ))}
                </div>
              )}
            </div>
          </Form.Item>

          <div className="p-3 bg-blue-50 rounded border border-blue-200">
            <p className="text-sm text-blue-700">
              {I18n.t('template_publish_notice')}
            </p>
          </div>
        </Card.Content>
      )}
    </Card>
  );
};
```

#### 发布页面集成

**文件位置**: 修改现有的 `frontend/packages/agent-ide/agent-publish/src/components/bot-publish/publish-table/index.tsx`

```typescript
// 在现有发布组件中添加模板发布功能
import { TemplatePublishSection } from '../../template-publish-section';
import { template_publish } from '@coze-studio/api-schema';

// 在组件状态中添加
const [templatePublishData, setTemplatePublishData] = useState<{
  enabled: boolean;
  data?: TemplatePublishData;
}>({ enabled: false });

// 在发布逻辑中集成模板发布
const handlePublish = async () => {
  try {
    // 原有的智能体发布逻辑
    const publishResult = await publishAgent(publishData);
    
    if (!publishResult.success) {
      throw new Error('Agent publish failed');
    }
    
    // 如果选择发布为模板
    if (templatePublishData.enabled && templatePublishData.data) {
      try {
        await template_publish.PublishAsTemplate({
          agent_id: parseInt(bot_id),
          ...templatePublishData.data,
        });
        
        toast.success(I18n.t('publish_success_with_template'));
      } catch (templateError) {
        console.error('Template publish failed:', templateError);
        toast.warning(I18n.t('agent_published_template_failed'));
      }
    } else {
      toast.success(I18n.t('publish_success'));
    }
    
  } catch (error) {
    console.error('Publish failed:', error);
    toast.error(I18n.t('publish_failed'));
  }
};

// 在渲染中添加模板发布组件
return (
  <div className="publish-container">
    {/* 现有发布内容 */}
    
    <TemplatePublishSection
      agentInfo={{
        id: bot_id,
        name: botInfo?.name || '',
        description: botInfo?.description || '',
        iconUrl: botInfo?.icon_url,
      }}
      onToggle={(enabled, data) => setTemplatePublishData({ enabled, data })}
      disabled={!canPublish}
    />
    
    {/* 现有发布按钮等 */}
  </div>
);
```

### 4. 数据库改动

**数据表**: 使用现有的 `template` 表，仅需添加索引

```sql
-- 添加必要的索引以支持用户模板查询
ALTER TABLE template ADD COLUMN creator_id bigint DEFAULT 0 COMMENT 'Template creator user ID';
ALTER TABLE template ADD INDEX idx_creator_id (creator_id);
ALTER TABLE template ADD INDEX idx_entity_type_status (product_entity_type, creator_id);
ALTER TABLE template ADD INDEX idx_space_created_at (space_id, created_at DESC);
```

### 5. 路由注册

**文件位置**: 需要在 `backend/api/router/register.go` 的 INSERT_POINT 处添加路由注册

```go
//INSERT_POINT: DO NOT DELETE THIS LINE!
template_publish.Register(r)
```

## 🚀 实施计划

### 第一阶段任务清单（基础功能）

1. **后端开发**
   - [ ] 创建 IDL 文件 `idl/template/template_publish.thrift`
   - [ ] 运行 `hz update` 生成后端代码
   - [ ] 实现 `backend/application/template/publish.go` 业务逻辑
   - [ ] 添加必要的数据库索引
   - [ ] 添加路由注册

2. **前端开发**  
   - [ ] 运行 `npm run update` 生成前端 API 代码
   - [ ] 实现 `TemplatePublishSection` 组件
   - [ ] 集成到现有发布页面
   - [ ] 添加相关 i18n 文本

3. **测试验证**
   - [ ] 智能体发布为模板功能测试
   - [ ] 模板在模板库中正确显示
   - [ ] 我的模板列表功能测试
   - [ ] 模板删除功能测试

### 预期工期

- **后端开发**: 2-3天
- **前端开发**: 2-3天  
- **联调测试**: 1天
- **总计**: 5-7天

### 技术风险

- **低风险**: 基于现有成熟架构，风险可控
- **注意事项**: 
  - 确保数据转换逻辑正确
  - 前端发布流程用户体验流畅
  - 权限验证严格

## 📊 后续阶段规划

### 第二阶段：完善功能（预计2周）
- 我的模板管理页面
- 模板分类和标签系统
- 模板使用统计和分析

### 第三阶段：高级功能（预计3周）  
- 模板审核机制
- 模板评分和评论系统
- 模板推荐算法

---

**文档版本**: v1.0  
**创建日期**: 2025-01-13  
**最后更新**: 2025-01-13